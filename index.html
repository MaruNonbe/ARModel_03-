UIã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã‚‚åå¿œã—ãªã„ï¼ˆãƒœã‚¿ãƒ³ãŒæŠ¼ã›ãªã„ã€ã¾ãŸã¯å‹•ä½œã—ãªã„ï¼‰åŸå› ã¨ã—ã¦ã€\*\*ã€Œé€æ˜ãªç”»é¢ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é‡ãªã‚Šé †ï¼ˆZ-indexï¼‰ã€**ã‚„**ã€Œã‚¹ãƒãƒ›ç‰¹æœ‰ã®ã‚¿ãƒƒãƒæ“ä½œã®ç«¶åˆã€\*\*ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

ç‰¹ã«ã€å‰å›ã€Œä¸Šä¸‹ã«UIã‚’åˆ†ã‘ãŸã€éš›ã«ã€ç›®ã«è¦‹ãˆãªã„é€æ˜ãªãƒœãƒƒã‚¯ã‚¹ãŒç”»é¢ã‚’è¦†ã£ã¦ã—ã¾ã„ã€ãƒœã‚¿ãƒ³ã¸ã®ã‚¿ãƒƒãƒã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

ä»¥ä¸‹ã®ä¿®æ­£ã‚’è¡Œã„ã¾ã—ãŸã€‚ã“ã‚Œã§ç¢ºå®Ÿã«ãƒœã‚¿ãƒ³ãŒåå¿œã—ã€æ“ä½œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

1.  **ã‚¿ãƒƒãƒåˆ¤å®šã®å¼·åŒ–:** ãƒœã‚¿ãƒ³ã« `touch-action: manipulation` ã‚’è¿½åŠ ã—ã€ã‚¹ãƒãƒ›ã§ã®ã‚¿ãƒƒãƒæ„Ÿåº¦ã‚’æœ€é©åŒ–ã—ã¾ã—ãŸã€‚
2.  **ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºã®å¼·åˆ¶:** UIã‚’ `z-index: 999999` ã«è¨­å®šã—ã€ARæ˜ åƒã‚„ä»–ã®è¦ç´ ã‚ˆã‚Šã‚‚ã€Œçµ¶å¯¾ã«æ‰‹å‰ã€ã«æ¥ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚
3.  **ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®äºˆå‚™:** ã‚¿ãƒƒãƒæ“ä½œã ã‘ã§ãªãã€å¿µã®ãŸã‚ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã‚‚å¼·åŒ–ã—ã¾ã—ãŸã€‚

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ `index.html` ã«ä¸Šæ›¸ãã—ã¦ãã ã•ã„ã€‚

```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>AR Train UI Touch Fix</title>

  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

  <style>
    /* ========== åŸºæœ¬è¨­å®š ========== */
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background: transparent; font-family: sans-serif;
      /* å…¨ä½“é¸æŠç„¡åŠ¹åŒ–ã¯å‰Šé™¤ã—ã€ãƒœã‚¿ãƒ³ã®ã¿ã«é©ç”¨ */
    }
    a-scene { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

    /* ========== UIé…ç½®ï¼ˆæœ€å‰é¢æŒ‡å®šï¼‰ ========== */
    #top-ui-container, #bottom-ui-container {
      position: fixed; left: 0; width: 100%;
      /* â˜…ä¿®æ­£ï¼šZ-indexã‚’éå¸¸ã«å¤§ããã—ã¦ç¢ºå®Ÿã«æ‰‹å‰ã«ã™ã‚‹ */
      z-index: 999999;
      display: flex; flex-direction: column; align-items: center;
      gap: 10px;
      /* ã‚³ãƒ³ãƒ†ãƒŠè‡ªä½“ã¯ã‚¿ãƒƒãƒã‚’é€šã™ */
      pointer-events: none;
    }

    #top-ui-container { top: 20px; }
    #bottom-ui-container { bottom: 30px; }

    /* ========== ãƒœã‚¿ãƒ³ç¾¤ã®èƒŒæ™¯ ========== */
    .ui-bar, .pad-grid {
      pointer-events: auto; /* ã“ã“ã§ã‚¿ãƒƒãƒã‚’å—ã‘å–ã‚‹ */
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border-radius: 15px;
    }
    .ui-bar { display: flex; gap: 8px; padding: 5px 10px; }
    .pad-grid {
      display: grid;
      grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px);
      gap: 8px; padding: 15px; border-radius: 20px;
    }

    /* ========== ãƒœã‚¿ãƒ³å…±é€šã‚¹ã‚¿ã‚¤ãƒ« ========== */
    .btn {
      /* â˜…ä¿®æ­£ï¼šã‚¿ãƒƒãƒæ“ä½œã‚’ç¢ºå®Ÿã«ã™ã‚‹è¨­å®š */
      pointer-events: auto;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none; -webkit-user-select: none;
      
      width: 60px; height: 60px;
      background: #ffffff; border: none; border-radius: 12px;
      display: flex; justify-content: center; align-items: center;
      font-size: 26px; color: #556677;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); cursor: pointer;
    }
    
    /* æŠ¼ã—ãŸã¨ãã®è¦‹ãŸç›®ï¼ˆåå¿œç¢ºèªç”¨ï¼‰ */
    .btn:active { 
      transform: scale(0.92); 
      background: #eeeeee; 
    }

    /* ã‚¢ã‚¤ã‚³ãƒ³ãƒ»æ–‡å­—èª¿æ•´ */
    .btn-icon { flex-direction: column; gap: 2px; font-size: 10px; color: #333; }
    .btn-icon span { font-size: 22px; line-height: 1; }
    .btn-icon div { font-weight: bold; }
    
    .btn-stop { background: #ffcccc; color: #d00; font-size: 15px; font-weight: bold; }
  </style>
</head>
<body>

<a-scene
  vr-mode-ui="enabled: false"
  embedded
  arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
  renderer="precision: mediump; antialias: true; alpha: true;"
>
  <a-light type="ambient" color="#FFF" intensity="0.8"></a-light>
  <a-light type="directional" position="-1 2 1" intensity="0.6"></a-light>

  <a-camera position="0 1.6 0" look-controls="enabled: true; touchEnabled: false; mouseEnabled: false"></a-camera>

  <a-entity id="train"
            gltf-model="models/AR-Train_Nagai.glb"
            position="0 0 -2"
            rotation="0 0 0"
            scale="0.5 0.5 0.5">
  </a-entity>
</a-scene>

<div id="top-ui-container">
  <div class="ui-bar">
    <div class="btn btn-icon" id="btn-face"><span>ğŸ™‚</span><div>é¡”</div></div>
    <div class="btn btn-icon" id="btn-up"><span>â¬†</span><div>é«˜</div></div>
    <div class="btn btn-icon" id="btn-down"><span>â¬‡</span><div>ä½</div></div>
    <div class="btn btn-icon" id="btn-zoom-in"><span>ğŸ”+</span></div>
    <div class="btn btn-icon" id="btn-zoom-out"><span>ğŸ”-</span></div>
  </div>
  <div class="ui-bar">
    <div class="btn btn-icon" id="btn-capture"><span>ğŸ“·</span><div>æ’®</div></div>
  </div>
</div>

<div id="bottom-ui-container">
  <div class="pad-grid">
    <div class="btn" id="btn-curve-left-fwd">â†–</div>
    <div class="btn" id="btn-fwd">â†‘</div>
    <div class="btn" id="btn-curve-right-fwd">â†—</div>
    <div class="btn" id="btn-turn-left">â†º</div>
    <div class="btn btn-stop" id="btn-stop">STOP</div>
    <div class="btn" id="btn-turn-right">â†»</div>
    <div class="btn" id="btn-curve-left-back">â†™</div>
    <div class="btn" id="btn-back">â†“</div>
    <div class="btn" id="btn-curve-right-back">â†˜</div>
  </div>
</div>

<script>
/* ========== ãƒ­ã‚¸ãƒƒã‚¯ ========== */
const train = document.querySelector('#train');

let speed = 0.05;
let turnSpeedInPlace = 2.0; 
let turnSpeedCurve = 1.0;   
let state = { moving: 0, turning: 0 };

function loop() {
  requestAnimationFrame(loop);
  if (!train.object3D) return;
  const mesh = train.object3D;

  if (state.turning !== 0) {
    let rotationAmount = 0;
    if (state.moving !== 0) {
      rotationAmount = THREE.MathUtils.degToRad(turnSpeedCurve) * state.turning;
      if (state.moving === -1) rotationAmount *= -1; 
    } else {
      rotationAmount = THREE.MathUtils.degToRad(turnSpeedInPlace) * state.turning;
    }
    mesh.rotation.y += rotationAmount;
  }

  if (state.moving !== 0) {
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(mesh.quaternion);
    forward.normalize();
    mesh.position.addScaledVector(forward, state.moving * speed);
  }
}
loop();

// ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šï¼ˆã‚¿ãƒƒãƒï¼†ãƒã‚¦ã‚¹å¯¾å¿œï¼‰
function setAction(id, moveVal, turnVal) {
  const btn = document.getElementById(id);
  if(!btn) return;

  const start = (e) => { 
    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç­‰ã‚’é˜²ãï¼ˆãƒœã‚¿ãƒ³åå¿œã‚’è‰¯ãã™ã‚‹ï¼‰
    if(e.cancelable && e.type === 'touchstart') e.preventDefault();
    state.moving = moveVal; 
    state.turning = turnVal; 
  };
  const end = (e) => { 
    if(e.cancelable && e.type === 'touchend') e.preventDefault();
    state.moving = 0; 
    state.turning = 0; 
  };

  btn.addEventListener('touchstart', start, {passive:false});
  btn.addEventListener('mousedown', start);
  
  btn.addEventListener('touchend', end, {passive:false});
  btn.addEventListener('mouseup', end);
  btn.addEventListener('mouseleave', end);
}

// ãƒœã‚¿ãƒ³å‰²ã‚Šå½“ã¦
setAction('btn-fwd', 1, 0); 
setAction('btn-back', -1, 0);
setAction('btn-turn-left', 0, 1); 
setAction('btn-turn-right', 0, -1);
setAction('btn-curve-left-fwd', 1, 1); 
setAction('btn-curve-right-fwd', 1, -1);
setAction('btn-curve-left-back', -1, 1); 
setAction('btn-curve-right-back', -1, -1);
document.getElementById('btn-stop').addEventListener('click', (e)=>{ e.preventDefault(); state.moving=0; state.turning=0; });

document.getElementById('btn-up').onclick = () => train.object3D.position.y += 0.1;
document.getElementById('btn-down').onclick = () => train.object3D.position.y -= 0.1;

let curScale = 0.5;
document.getElementById('btn-zoom-in').onclick = () => { curScale += 0.05; train.object3D.scale.set(curScale,curScale,curScale); };
document.getElementById('btn-zoom-out').onclick = () => { curScale = Math.max(0.1, curScale - 0.05); train.object3D.scale.set(curScale,curScale,curScale); };

document.getElementById('btn-capture').onclick = () => {
  const cvs = document.querySelector('canvas');
  cvs.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='ar_snapshot.png'; a.click(); });
};

/* ========== é¡”å†™çœŸè¨­å®šï¼ˆFace_Plateå¯¾å¿œãƒ»åº§æ¨™èª¿æ•´æ¸ˆã¿ï¼‰ ========== */
document.getElementById('btn-face').onclick = () => {
  if (!train.object3D) { alert("ãƒ¢ãƒ‡ãƒ«èª­è¾¼ä¸­..."); return; }

  const input = document.createElement('input');
  input.type = 'file'; input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;

    const url = URL.createObjectURL(file);
    new THREE.TextureLoader().load(url, (tex) => {
      tex.encoding = THREE.sRGBEncoding;
      tex.flipY = false; 

      // Face_Plate ã‚’æ¢ã—ã¦ãƒãƒ†ãƒªã‚¢ãƒ«ç½®æ›
      const facePlate = train.object3D.getObjectByName('Face_Plate');
      if (facePlate) {
        facePlate.material = new THREE.MeshBasicMaterial({
          map: tex,
          side: THREE.DoubleSide,
          transparent: true
        });
      } else {
        // ä¸‡ãŒä¸€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€åº§æ¨™æŒ‡å®šã§å¼·åˆ¶ç”Ÿæˆï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
        const geo = new THREE.PlaneGeometry(0.7, 0.7);
        const mat = new THREE.MeshBasicMaterial({ 
          map: tex, side: THREE.DoubleSide, transparent:true, depthTest: false, depthWrite: false 
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.name = 'custom_face';
        mesh.renderOrder = 999; 
        mesh.position.set(0.65, 2.35, 2.5); 
        train.object3D.add(mesh);
      }
    });
  };
  input.click();
};

window.addEventListener('resize', () => {
  const scene = document.querySelector('a-scene');
  if(scene.camera) { scene.camera.aspect = window.innerWidth / window.innerHeight; scene.camera.updateProjectionMatrix(); }
});
</script>
</body>
</html>
```